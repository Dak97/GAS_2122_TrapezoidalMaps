#include "trapmap.h"

#include <cg3/viewer/opengl_objects/opengl_objects2.h>
#include "algorithm.h"
/**
 * @brief TrapMap::TrapMap Default constructor of the trapezoidal map object
 */
TrapMap::TrapMap()
{
    // initializie trapezoidal map
    init();
}
/**
 * @brief TrapMap::init Add the default trapezoid (corrisponding to the bounding box) to the trapezoidal map
 */
void TrapMap::init(){
    addNewTrapezoid();
}

/**
 * @brief TrapMap::getTrapezoids Return the list of the trapezoids in the trapezoidal map
 * @return List of the trapezoids
 */
const std::list<Trapezoid> TrapMap::getTrapezoids() const{
    return trapezoids;
}

/**
 * @brief TrapMap::getFirstTrapezoid Return the first trapezoid in the list of the trapezoids
 * @return The first trapezoid
 */
Trapezoid* TrapMap::getFirstTrapezoid(){
    std::list<Trapezoid>::iterator it=trapezoids.begin();
    return &*it;
}

/**
 * @brief TrapMap::deleteTrapezoidByRef Elimination of the trapezoids in the list of the trapezoids
 * @param traps List of the trapezoids that have to be deleted
 */
void TrapMap::deleteTrapezoidByRef(std::vector<Trapezoid*> traps){
    for (const Trapezoid* t : traps){
        trapezoids.erase(t->getRefToIter());
    }
}
/**
 * @brief TrapMap::clear Elimination of the entire list of the trapezoids
 */
void TrapMap::clear(){
    trapezoids.clear();
}

/**
  * @brief TrapMap::addNewTrapezoid Insertion of a default trapezoid in the list of trapezoids
  * @return The new trapezoid inserted
  */
 Trapezoid* TrapMap::addNewTrapezoid(){
    // add a default trapezoid to the list
    trapezoids.push_back(Trapezoid());

    // add a reference to iterator list
    trapezoids.back().setRefToIter(--(trapezoids.end()));

    return  &*(--(trapezoids.end()));
}
 /**
 * @brief TrapMap::findIntersectionVerticalLine Find the point that intersect a segment and x point coordinate
 * @param s The segment
 * @param px x point coordinate
 * @return The point intersected
 */
cg3::Point2d TrapMap::findIntersectionVerticalLine(const cg3::Segment2d& s, const cg3::Point2d& px){

    double a, b, c, y;

    a = s.p1().y() - s.p2().y();
    b = s.p2().x() - s.p1().x();
    c = ((s.p1().x() * s.p2().y()) - (s.p2().x() * s.p1().y()));

    y = (-c -(a * px.x())) / b;

    return cg3::Point2d(px.x(), y);
}
/**
 * @brief TrapMap::newTrapezoidsSingleSplit Create trapezoids generated by a segment compleatly inside another trapezoid
 * @param segment the segment inserted
 * @param bb1 Trapezoid where the segment is inside
 * @param left_coincident flag if the segment is left coincident
 * @param right_coincident flag if the segment is right coincident
 * @return A vector of the new trapezoids
 */
std::vector<Trapezoid*> TrapMap::newTrapezoidsSingleSplit(const cg3::Segment2d& segment,  Trapezoid* bb1, bool &left_coincident, bool &right_coincident){
    cg3::Segment2d topS, bottomS;
    cg3::Point2d leftP, rightP, p1, q1;
    cg3::Color colorT;
    Trapezoid *left, *top, *bottom, *right;

    std::vector<Trapezoid*> trapForDag;
    Trapezoid bb = *bb1;

    int idLastTrap = trapezoids.back().getId();


    p1 = segment.p1();
    q1 = segment.p2();

    if (p1.operator==(bb.getLeftPoint())){
        left_coincident = true;
    }
    if (q1.operator==(bb.getRightPoint())){
        right_coincident = true;
    }

    // create and add a new default trapezoids in the trapezoid's list
    if (!left_coincident)
        left = addNewTrapezoid();
    top = addNewTrapezoid();
    bottom = addNewTrapezoid();
    if (!right_coincident)
        right = addNewTrapezoid();

    ////////////////////
    // LEFT trapezoid //
    ////////////////////
    if (!left_coincident){
        colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
        left->setTrapezoid(++idLastTrap,
                           cg3::Segment2d(bb.getSegmentUp().p1(),findIntersectionVerticalLine(bb.getSegmentUp(), p1)),
                           cg3::Segment2d(bb.getSegmentDown().p1(),findIntersectionVerticalLine(bb.getSegmentDown(), p1)),
                           bb.getLeftPoint(), p1,
                           colorT);

    }

    ////////////////////
    // TOP trapezoid  //
    ////////////////////
    colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
    top->setTrapezoid(++idLastTrap,
                      cg3::Segment2d(findIntersectionVerticalLine(bb.getSegmentUp(), p1),findIntersectionVerticalLine(bb.getSegmentUp(), q1)),
                      segment,
                      p1, q1,
                      colorT);

    //////////////////////
    // BOTTOM trapezoid //
    //////////////////////

    colorT = cg3::Color(rand()%256, rand()%256, rand()%256);

    bottom->setTrapezoid(++idLastTrap,
                         segment,
                         cg3::Segment2d(findIntersectionVerticalLine(bb.getSegmentDown(), p1),findIntersectionVerticalLine(bb.getSegmentDown(), q1)),
                         p1, q1,
                         colorT);

    /////////////////////
    // RIGHT trapezoid //
    /////////////////////

    if (!right_coincident){
        colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
        right->setTrapezoid(++idLastTrap,
                            cg3::Segment2d(findIntersectionVerticalLine(bb.getSegmentUp(), q1), bb.getSegmentUp().p2()),
                            cg3::Segment2d(findIntersectionVerticalLine(bb.getSegmentDown(), q1), bb.getSegmentDown().p2()),
                            q1, bb.getRightPoint(),
                            colorT);
    }

    //////////////////////
    // SETTING NEIGHBOR //
    //////////////////////

    if (!left_coincident && !right_coincident){
        left->setNeighbor(bb.getTopLeftNeigh(), bb.getBottomLeftNeigh(), top, bottom);
        if (bb.getTopLeftNeigh() != nullptr && bb.getBottomLeftNeigh() != nullptr
                && (bb.getTopLeftNeigh()->getId() == bb.getBottomLeftNeigh()->getId())){
            // bb ha gli stessi left neighbors
            if (bb.getTopLeftNeigh()->sameRightNeighbor()){
                // il left neighbor di bb ha gli stessi right neighbors
                bb.getTopLeftNeigh()->setTopRightNeigh(left);
                bb.getTopLeftNeigh()->setBottomRightNeigh(left);
            }else{
                // il left neighbor di bb ha diversi right neighbors
                if (bb.getId() == bb.getTopLeftNeigh()->getBottomRightNeigh()->getId()){
                    // il nuovo segment si trova sotto
                    bb.getBottomLeftNeigh()->setBottomRightNeigh(left);
                }
                else{
                    // il nuovo segmento si trova sopra
                    bb.getTopLeftNeigh()->setTopRightNeigh(left);
                }
            }
        }else if(bb.getTopLeftNeigh() != nullptr && bb.getBottomLeftNeigh() != nullptr
                 && (bb.getTopLeftNeigh()->getId() != bb.getBottomLeftNeigh()->getId())){
            bb.getTopLeftNeigh()->setTopRightNeigh(left);
            bb.getTopLeftNeigh()->setBottomRightNeigh(left);
            bb.getBottomLeftNeigh()->setTopRightNeigh(left);
            bb.getBottomLeftNeigh()->setBottomRightNeigh(left);
        }

        top->setNeighbor(left, left, right, right);
        bottom->setNeighbor(left, left, right, right);

        right->setNeighbor(top, bottom, bb.getTopRightNeigh(), bb.getBottomRightNeigh());
        if (bb.getTopRightNeigh() != nullptr && bb.getBottomRightNeigh() != nullptr &&
                (bb.getTopRightNeigh()->getId() == bb.getBottomRightNeigh()->getId())){
            if (bb.getTopRightNeigh()->sameLeftNeighbor()){
                bb.getTopRightNeigh()->setTopLeftNeigh(right);
                bb.getTopRightNeigh()->setBottomLeftNeigh(right);
            }else{
                if (bb.getId() == bb.getTopRightNeigh()->getBottomLeftNeigh()->getId()){
                    bb.getBottomRightNeigh()->setBottomLeftNeigh(right);
                }else{
                    bb.getTopRightNeigh()->setTopLeftNeigh(right);
                }
            }
        }else if (bb.getTopRightNeigh() != nullptr && bb.getBottomRightNeigh() != nullptr

                  && (bb.getTopRightNeigh()->getId() != bb.getBottomRightNeigh()->getId())){
            bb.getTopRightNeigh()->setTopLeftNeigh(right);
            bb.getTopRightNeigh()->setBottomLeftNeigh(right);
            bb.getBottomRightNeigh()->setTopLeftNeigh(right);
            bb.getBottomRightNeigh()->setBottomLeftNeigh(right);
        }

        trapForDag.push_back(left);
        trapForDag.push_back(top);
        trapForDag.push_back(bottom);
        trapForDag.push_back(right);

    }else if (left_coincident && right_coincident){
        // right and left coincidence
        if (top->isLeftDegenerate() && bottom->isRightDegenerate()){
            top->setNeighbor(nullptr, nullptr, bb.getTopRightNeigh(), bb.getTopRightNeigh());
            bottom->setNeighbor(bb.getTopLeftNeigh(), bb.getTopLeftNeigh(), nullptr, nullptr);

            if (bb.getTopLeftNeigh()->sameRightNeighbor()){
                bb.getTopLeftNeigh()->setTopRightNeigh(bottom);
                bb.getTopLeftNeigh()->setBottomRightNeigh(bottom);
            }else
                bb.getTopLeftNeigh()->setBottomRightNeigh(bottom);

            if (bb.getTopRightNeigh()->sameLeftNeighbor()){
                bb.getTopRightNeigh()->setTopLeftNeigh(top);
                bb.getTopRightNeigh()->setBottomLeftNeigh(top);
            }else
                bb.getTopRightNeigh()->setTopLeftNeigh(top);



        }else if (top->isRightDegenerate() && bottom->isLeftDegenerate()){
            top->setNeighbor(bb.getTopLeftNeigh(), bb.getTopLeftNeigh(), nullptr, nullptr);
            bottom->setNeighbor(nullptr, nullptr, bb.getTopRightNeigh(), bb.getTopRightNeigh());

            if (bb.getTopLeftNeigh()->sameRightNeighbor()){
                bb.getTopLeftNeigh()->setTopRightNeigh(top);
                bb.getTopLeftNeigh()->setBottomRightNeigh(top);
            }else
                bb.getTopLeftNeigh()->setTopRightNeigh(top);

            if (bb.getTopRightNeigh()->sameLeftNeighbor()){
                bb.getTopRightNeigh()->setTopLeftNeigh(bottom);
                bb.getTopRightNeigh()->setBottomLeftNeigh(bottom);
            }else
                bb.getTopRightNeigh()->setBottomLeftNeigh(bottom);

        } else if (top->isLeftDegenerate() && bottom->isLeftDegenerate()){
            top->setNeighbor(nullptr, nullptr, bb.getTopRightNeigh(), bb.getTopRightNeigh());
            bottom->setNeighbor(nullptr, nullptr, bb.getBottomRightNeigh(), bb.getBottomRightNeigh());

            bb.getTopRightNeigh()->setTopLeftNeigh(top);
            bb.getTopRightNeigh()->setBottomLeftNeigh(top);

            bb.getBottomRightNeigh()->setTopLeftNeigh(bottom);
            bb.getBottomRightNeigh()->setBottomLeftNeigh(bottom);

        }else if (top->isRightDegenerate() && bottom->isRightDegenerate()){
            top->setNeighbor(bb.getTopLeftNeigh(), bb.getTopLeftNeigh(), nullptr, nullptr);
            bottom->setNeighbor(bb.getBottomLeftNeigh(), bb.getBottomLeftNeigh(), nullptr, nullptr);

            bb.getTopLeftNeigh()->setTopRightNeigh(top);
            bb.getTopLeftNeigh()->setBottomRightNeigh(top);

            bb.getBottomLeftNeigh()->setTopRightNeigh(bottom);
            bb.getBottomLeftNeigh()->setBottomRightNeigh(bottom);
        }

        else if (top->isLeftDegenerate() || top->isRightDegenerate()){

            if (top->isLeftDegenerate()){
                top->setNeighbor(nullptr, nullptr, bb.getTopRightNeigh(), bb.getTopRightNeigh());
                bb.getTopRightNeigh()->setTopLeftNeigh(top);
                bb.getTopRightNeigh()->setBottomLeftNeigh(top);
            }
            else{
                top->setNeighbor(bb.getTopLeftNeigh(), bb.getTopLeftNeigh(), nullptr, nullptr);
                bb.getTopLeftNeigh()->setTopRightNeigh(top);
                bb.getTopLeftNeigh()->setBottomRightNeigh(top);
            }

            bottom->setNeighbor(bb.getBottomLeftNeigh(), bb.getBottomLeftNeigh(), bb.getBottomRightNeigh(), bb.getBottomRightNeigh());

            // update left neighbors
            if (Algorithm::pointsAreEquals(bb.getLeftPoint(), bb.getSegmentUp().p1())){
                // same left neighbor
                if (bb.getTopLeftNeigh()->sameRightNeighbor()){
                    bb.getTopLeftNeigh()->setTopRightNeigh(bottom);
                    bb.getTopLeftNeigh()->setBottomRightNeigh(bottom);
                }else
                    bb.getTopLeftNeigh()->setBottomRightNeigh(bottom);
            }else{
                // different left neignors
                bb.getBottomLeftNeigh()->setTopRightNeigh(bottom);
                bb.getBottomLeftNeigh()->setBottomRightNeigh(bottom);
            }

            // update right neighbors
            if (Algorithm::pointsAreEquals(bb.getRightPoint(), bb.getSegmentUp().p2())){
                // same right neighbors
                if (bb.getTopRightNeigh()->sameLeftNeighbor()){
                    bb.getTopRightNeigh()->setTopLeftNeigh(bottom);
                    bb.getTopRightNeigh()->setBottomLeftNeigh(bottom);
                }else
                    bb.getTopRightNeigh()->setBottomLeftNeigh(bottom);
            }else{
                // different right neignors
                bb.getBottomRightNeigh()->setTopLeftNeigh(bottom);
                bb.getBottomRightNeigh()->setBottomLeftNeigh(bottom);
            }

        }else if (bottom->isLeftDegenerate() || bottom->isRightDegenerate()){

             top->setNeighbor(bb.getTopLeftNeigh(), bb.getTopLeftNeigh(), bb.getTopRightNeigh(), bb.getTopRightNeigh());

            if (bottom->isLeftDegenerate()){
                bottom->setNeighbor(nullptr, nullptr, bb.getBottomRightNeigh(), bb.getBottomRightNeigh());
                bb.getBottomRightNeigh()->setTopLeftNeigh(bottom);
                bb.getBottomRightNeigh()->setBottomLeftNeigh(bottom);
            }
            else{
                bottom->setNeighbor(bb.getBottomLeftNeigh(), bb.getBottomLeftNeigh(), nullptr, nullptr);
                bb.getBottomLeftNeigh()->setTopRightNeigh(bottom);
                bb.getBottomLeftNeigh()->setBottomRightNeigh(bottom);
            }

            // update left neighbors
            if (Algorithm::pointsAreEquals(bb.getLeftPoint(), bb.getSegmentDown().p1())){
                // same left neighbors
                if (bb.getTopLeftNeigh()->sameRightNeighbor()){
                    bb.getTopLeftNeigh()->setTopRightNeigh(top);
                    bb.getTopLeftNeigh()->setBottomRightNeigh(top);
                }else
                    bb.getTopLeftNeigh()->setTopRightNeigh(top);
            }else{
                // different left neignors
                bb.getTopLeftNeigh()->setTopRightNeigh(top);
                bb.getTopLeftNeigh()->setBottomRightNeigh(top);
            }
            // update right neighbors
            if (Algorithm::pointsAreEquals(bb.getRightPoint(), bb.getSegmentDown().p2())){
                // same right neighbors
                if (bb.getTopRightNeigh()->sameLeftNeighbor()){
                    bb.getTopRightNeigh()->setTopLeftNeigh(top);
                    bb.getTopRightNeigh()->setBottomLeftNeigh(top);
                }else
                    bb.getTopRightNeigh()->setTopLeftNeigh(top);
            }else{
                // different right neignors
                bb.getTopRightNeigh()->setTopLeftNeigh(top);
                bb.getTopRightNeigh()->setBottomLeftNeigh(top);
            }
        }else{

            // no degenerate point
            top->setNeighbor(bb.getTopLeftNeigh(), bb.getTopLeftNeigh(), bb.getTopRightNeigh(), bb.getTopRightNeigh());
            bottom->setNeighbor(bb.getBottomLeftNeigh(), bb.getBottomLeftNeigh(), bb.getBottomRightNeigh(), bb.getBottomRightNeigh());

            bb.getTopLeftNeigh()->setTopRightNeigh(top);
            bb.getTopLeftNeigh()->setBottomRightNeigh(top);
            bb.getTopRightNeigh()->setTopLeftNeigh(top);
            bb.getTopRightNeigh()->setBottomLeftNeigh(top);

            bb.getBottomLeftNeigh()->setTopRightNeigh(bottom);
            bb.getBottomLeftNeigh()->setBottomRightNeigh(bottom);
            bb.getBottomRightNeigh()->setTopLeftNeigh(bottom);
            bb.getBottomRightNeigh()->setBottomLeftNeigh(bottom);
        }


        trapForDag.push_back(top);
        trapForDag.push_back(bottom);
    }else if (left_coincident){
       right->setNeighbor(top, bottom, bb.getTopRightNeigh(), bb.getBottomRightNeigh());

       if (bb.getTopRightNeigh() != nullptr && bb.getBottomRightNeigh() != nullptr){
           if (bb.sameRightNeighbor()){
               // same right neighbors
               if (!bb.getTopRightNeigh()->sameLeftNeighbor()){
                   // right neighbor has different left neighbors
                   if (bb.getId() == bb.getTopRightNeigh()->getBottomLeftNeigh()->getId()){
                       bb.getTopRightNeigh()->setBottomLeftNeigh(right);
                   }else{
                       bb.getTopRightNeigh()->setTopLeftNeigh(right);
                   }
               }else{
                   bb.getTopRightNeigh()->setTopLeftNeigh(right);
                   bb.getTopRightNeigh()->setBottomLeftNeigh(right);
               }
           }else{

               // different right neighbor
               bb.getTopRightNeigh()->setTopLeftNeigh(right);
               bb.getTopRightNeigh()->setBottomLeftNeigh(right);

               bb.getBottomRightNeigh()->setTopLeftNeigh(right);
               bb.getBottomRightNeigh()->setBottomLeftNeigh(right);
           }
       }

           if (bb.sameLeftNeighbor()){
               // should be a degenerate case
               if (bb.getTopLeftNeigh() != nullptr && bb.getBottomLeftNeigh() != nullptr){
               if (!bb.getTopLeftNeigh()->sameRightNeighbor()){
                   if (bb.getId() == bb.getTopLeftNeigh()->getBottomRightNeigh()->getId()){
                       top->setNeighbor(nullptr, nullptr, right, right);
                       bottom->setNeighbor(bb.getTopLeftNeigh(), bb.getBottomLeftNeigh(), right, right);

                       bb.getTopLeftNeigh()->setBottomRightNeigh(bottom);
                   }else{
                       bottom->setNeighbor(nullptr, nullptr, right, right);
                       top->setNeighbor(bb.getTopLeftNeigh(), bb.getBottomLeftNeigh(), right, right);

                       bb.getTopLeftNeigh()->setTopRightNeigh(top);
                   }
               }else{
                   // left neigh has same right neighbors
                   if (top->isLeftDegenerate()){
                       // segment is below
                       top->setNeighbor(nullptr, nullptr, right, right);
                       bottom->setNeighbor(bb.getTopLeftNeigh(), bb.getBottomLeftNeigh(), right, right);

                       bb.getTopLeftNeigh()->setTopRightNeigh(bottom);
                       bb.getTopLeftNeigh()->setBottomRightNeigh(bottom);
                   }else{
                       // segment is above
                       top->setNeighbor(bb.getTopLeftNeigh(), bb.getBottomLeftNeigh(), right, right);
                       bottom->setNeighbor(nullptr, nullptr, right, right);

                       bb.getTopLeftNeigh()->setTopRightNeigh(top);
                       bb.getTopLeftNeigh()->setBottomRightNeigh(top);
                   }
               }
               }else{
                   top->setNeighbor(nullptr, nullptr, right, right);
                   bottom->setNeighbor(nullptr, nullptr, right, right);
               }

           }else{
               // no degenerate case
               top->setNeighbor(bb.getTopLeftNeigh(), bb.getTopLeftNeigh(), right, right);
               bottom->setNeighbor(bb.getBottomLeftNeigh(), bb.getBottomLeftNeigh(), right, right);

               bb.getTopLeftNeigh()->setTopRightNeigh(top);
               bb.getTopLeftNeigh()->setBottomRightNeigh(top);

               bb.getBottomLeftNeigh()->setTopRightNeigh(bottom);
               bb.getBottomLeftNeigh()->setBottomRightNeigh(bottom);
           }


        trapForDag.push_back(top);
        trapForDag.push_back(bottom);
        trapForDag.push_back(right);

    }else if (right_coincident){
        left->setNeighbor(bb.getTopLeftNeigh(), bb.getBottomLeftNeigh(), top, bottom);

        if (bb.getTopLeftNeigh() != nullptr && bb.getBottomLeftNeigh() != nullptr){
            if (bb.sameLeftNeighbor())
            {
                // same left neighbor
                if (!bb.getTopLeftNeigh()->sameRightNeighbor()){
                    //left neigh has different right neighbors
                    if (bb.getId() == bb.getTopLeftNeigh()->getBottomRightNeigh()->getId()){
                        bb.getTopLeftNeigh()->setBottomRightNeigh(left);
                    }else{
                        bb.getTopLeftNeigh()->setTopRightNeigh(left);
                    }
                }else{
                    //left neigh has the same right neighbors
                    bb.getTopLeftNeigh()->setTopRightNeigh(left);
                    bb.getTopLeftNeigh()->setBottomRightNeigh(left);

                }

            }else{
                // different left neighbor
                bb.getTopLeftNeigh()->setTopRightNeigh(left);
                bb.getTopLeftNeigh()->setBottomRightNeigh(left);

                bb.getBottomLeftNeigh()->setTopRightNeigh(left);
                bb.getBottomLeftNeigh()->setBottomRightNeigh(left);
            }
        }

        if (bb.sameRightNeighbor()){
            // should be a degenerate case
            if (bb.getTopRightNeigh() != nullptr && bb.getBottomRightNeigh() != nullptr){
                if (!bb.getTopRightNeigh()->sameLeftNeighbor()){
                    if (bb.getId() == bb.getTopRightNeigh()->getBottomLeftNeigh()->getId()){
                        top->setNeighbor(left, left, nullptr, nullptr);
                        bottom->setNeighbor(left, left, bb.getTopRightNeigh(), bb.getBottomRightNeigh());

                        bb.getTopRightNeigh()->setBottomLeftNeigh(bottom);
                    }else{
                        bottom->setNeighbor(left, left, nullptr, nullptr);
                        top->setNeighbor(left, left, bb.getTopRightNeigh(), bb.getBottomRightNeigh());

                        bb.getTopRightNeigh()->setTopLeftNeigh(top);
                    }
                }else{
                    // right neigh has same left neighbors
                    if (top->isRightDegenerate()){
                        top->setNeighbor(left, left, nullptr, nullptr);
                        bottom->setNeighbor(left, left, bb.getTopRightNeigh(), bb.getBottomRightNeigh());

                        bb.getTopRightNeigh()->setTopLeftNeigh(bottom);
                        bb.getTopRightNeigh()->setBottomLeftNeigh(bottom);
                    }else{
                        bottom->setNeighbor(left, left, nullptr, nullptr);
                        top->setNeighbor(left, left, bb.getTopRightNeigh(), bb.getBottomRightNeigh());

                        bb.getTopRightNeigh()->setTopLeftNeigh(top);
                        bb.getTopRightNeigh()->setBottomLeftNeigh(top);
                    }
                }
            }else{
                // top and right degenerate
                top->setNeighbor(left, left, nullptr, nullptr);
                bottom->setNeighbor(left, left, nullptr, nullptr);
            }
        }else{
            // no degenerate case
            top->setNeighbor(left, left, bb.getTopRightNeigh(), bb.getTopRightNeigh());
            bottom->setNeighbor(left, left, bb.getBottomRightNeigh(), bb.getBottomRightNeigh());

            bb.getTopRightNeigh()->setTopLeftNeigh(top);
            bb.getTopRightNeigh()->setBottomLeftNeigh(top);

            bb.getBottomRightNeigh()->setTopLeftNeigh(bottom);
            bb.getBottomRightNeigh()->setBottomLeftNeigh(bottom);
        }


        trapForDag.push_back(left);
        trapForDag.push_back(top);
        trapForDag.push_back(bottom);

    }

    return trapForDag;
}

/**
 * @brief TrapMap::splitInThreeRight Create trapezoid generated by the second end-point of the segment
 * @param d trapezoid that will not merge
 * @param e trapezoid that will be right
 * @param low vector of trapezoids that will merge below
 * @param up vector of trapezoids that will merge above
 * @param bb current trapezoid
 * @param segment the segment inserted
 * @param id last trapezoid id
 */
void TrapMap::splitInThreeRight(Trapezoid *d, Trapezoid *e, std::vector<Trapezoid*>& low, std::vector<Trapezoid*>& up,
                       Trapezoid& bb,  const cg3::Segment2d& segment, int id, bool& left_above_segment){
    cg3::Point2d p1, q1;
    cg3::Color colorT;

    int idLastTrap = id;

    p1 = segment.p1();
    q1 = segment.p2();

    if (e != nullptr){
        // segment is not right coincident
        if (left_above_segment){
            // merging
            low.back()->setSegmentUp(cg3::Segment2d(low.back()->getSegmentUp().p1(), q1));
            low.back()->setSegmentDown(cg3::Segment2d(low.back()->getSegmentDown().p1(), findIntersectionVerticalLine(bb.getSegmentDown(),q1)));
            low.back()->setRightPoint(q1);

            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            d->setTrapezoid(++idLastTrap,
                            cg3::Segment2d(bb.getSegmentUp().p1(),findIntersectionVerticalLine(bb.getSegmentUp(), q1)),
                            cg3::Segment2d(findIntersectionVerticalLine(segment, bb.getLeftPoint()), q1),
                            bb.getLeftPoint(), q1, colorT);

            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            e->setTrapezoid(++idLastTrap,
                            cg3::Segment2d(d->getSegmentUp().p2(), bb.getSegmentUp().p2()),
                            cg3::Segment2d(findIntersectionVerticalLine(bb.getSegmentDown(), q1), bb.getSegmentDown().p2()),
                            q1, bb.getRightPoint(), colorT);

        }else{
            // merging
            up.back()->setSegmentUp(cg3::Segment2d(up.back()->getSegmentUp().p1(), findIntersectionVerticalLine(bb.getSegmentUp(),q1)));
            up.back()->setSegmentDown(cg3::Segment2d(up.back()->getSegmentDown().p1(), q1));
            up.back()->setRightPoint(q1);

            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            d->setTrapezoid(++idLastTrap,
                            cg3::Segment2d(findIntersectionVerticalLine(segment, bb.getLeftPoint()),q1),
                            cg3::Segment2d(bb.getSegmentDown().p1(),findIntersectionVerticalLine(bb.getSegmentDown(), q1)),
                            bb.getLeftPoint(), q1, colorT);

            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            e->setTrapezoid(++idLastTrap,
                            cg3::Segment2d(findIntersectionVerticalLine(bb.getSegmentUp(), q1), bb.getSegmentUp().p2()),
                            cg3::Segment2d(d->getSegmentDown().p2(), bb.getSegmentDown().p2()),
                            q1, bb.getRightPoint(), colorT);
        }

    }else{
        // segment is right coincident
        if (left_above_segment){
            // merging
            low.back()->setSegmentUp(cg3::Segment2d(low.back()->getSegmentUp().p1(), q1));
            low.back()->setSegmentDown(cg3::Segment2d(low.back()->getSegmentDown().p1(), bb.getSegmentDown().p2()));
            low.back()->setRightPoint(q1);

            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            d->setTrapezoid(++idLastTrap,
                            cg3::Segment2d(bb.getSegmentUp().p1(),findIntersectionVerticalLine(bb.getSegmentUp(), q1)),
                            cg3::Segment2d(findIntersectionVerticalLine(segment, bb.getLeftPoint()), q1),
                            bb.getLeftPoint(), q1, colorT);

        }else{
            // merging
            up.back()->setSegmentUp(cg3::Segment2d(up.back()->getSegmentUp().p1(), bb.getSegmentUp().p2()));
            up.back()->setSegmentDown(cg3::Segment2d(up.back()->getSegmentDown().p1(), q1));
            up.back()->setRightPoint(q1);

            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            d->setTrapezoid(++idLastTrap,
                            cg3::Segment2d(findIntersectionVerticalLine(segment, bb.getLeftPoint()),q1),
                            cg3::Segment2d(bb.getSegmentDown().p1(),findIntersectionVerticalLine(bb.getSegmentDown(), q1)),
                            bb.getLeftPoint(), q1, colorT);
        }

    }
}
/**
 * @brief TrapMap::splitInThreeLeft Create trapezoid generated by the first end-point of the segment
 * @param a trapezoid that will be left
 * @param b trapezoid that will not merge
 * @param c_1 trapezoid that will merge
 * @param low vector of trapezoid that will merge below
 * @param up vector of trapezoid that will merge above
 * @param bb current trapezoid
 * @param segment segement inserted
 * @param id last rtapezoid id
 * @param right_above_segment flag if the segment is above the current right point
 */
void TrapMap::splitInThreeLeft(Trapezoid *a, Trapezoid *b, Trapezoid *c_1, std::vector<Trapezoid*>& low, std::vector<Trapezoid*>& up,
                         Trapezoid& bb, const cg3::Segment2d& segment, int id, bool& right_above_segment){
    cg3::Point2d p1, q1;
    cg3::Color colorT;

    int idLastTrap = id;

    p1 = segment.p1();
    q1 = segment.p2();

    if (a != nullptr){
        // segment is not left coincident
        colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
        a->setTrapezoid(++idLastTrap,
                        cg3::Segment2d(bb.getSegmentUp().p1(),findIntersectionVerticalLine(bb.getSegmentUp(),p1)),
                        cg3::Segment2d(bb.getSegmentDown().p1(),findIntersectionVerticalLine(bb.getSegmentDown(),p1)),
                        bb.getLeftPoint(), p1, colorT);

        if (right_above_segment){
            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            b->setTrapezoid(++idLastTrap,
                            cg3::Segment2d(a->getSegmentUp().p2(), findIntersectionVerticalLine(bb.getSegmentUp(), bb.getRightPoint())),
                            cg3::Segment2d(p1,findIntersectionVerticalLine(segment, bb.getRightPoint())),
                            p1, bb.getRightPoint(), colorT);
            up.push_back(b);

            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            c_1->setTrapezoid(++idLastTrap,
                              cg3::Segment2d(p1, b->getSegmentDown().p2()),
                              cg3::Segment2d(a->getSegmentDown().p2(), bb.getSegmentDown().p2()),
                              p1, b->getSegmentDown().p2(), colorT);

            low.push_back(c_1);
        }else{
            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            b->setTrapezoid(++idLastTrap,
                            cg3::Segment2d(p1,findIntersectionVerticalLine(segment,bb.getRightPoint())),
                            cg3::Segment2d(a->getSegmentDown().p2(),bb.getSegmentDown().p2()),
                            p1, bb.getRightPoint(), colorT);
            low.push_back(b);

            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            c_1->setTrapezoid(++idLastTrap,
                              cg3::Segment2d(a->getSegmentUp().p2(), bb.getSegmentUp().p2()),
                              cg3::Segment2d(p1, b->getSegmentUp().p2()),
                              p1, b->getSegmentUp().p2(), colorT);
            up.push_back(c_1);
        }
    }else{
        // segment is left coincident
        if (right_above_segment){
            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            b->setTrapezoid(++idLastTrap,
                           bb.getSegmentUp(),
                            cg3::Segment2d(p1,findIntersectionVerticalLine(segment, bb.getRightPoint())),
                            p1, bb.getRightPoint(), colorT);
            up.push_back(b);

            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            c_1->setTrapezoid(++idLastTrap,
                              cg3::Segment2d(p1, b->getSegmentDown().p2()),
                              cg3::Segment2d(bb.getSegmentDown().p1(), bb.getSegmentDown().p2()),
                              p1, b->getSegmentDown().p2(), colorT);

            low.push_back(c_1);
        }else{
            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            b->setTrapezoid(++idLastTrap,
                            cg3::Segment2d(p1,findIntersectionVerticalLine(segment,bb.getRightPoint())),
                            bb.getSegmentDown(),
                            p1, bb.getRightPoint(), colorT);
            low.push_back(b);
            colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
            c_1->setTrapezoid(++idLastTrap,
                              cg3::Segment2d(bb.getSegmentUp().p1(), bb.getSegmentUp().p2()),
                              cg3::Segment2d(p1, b->getSegmentUp().p2()),
                              p1, b->getSegmentUp().p2(), colorT);
            up.push_back(c_1);
        }
    }

}
/**
 * @brief TrapMap::splitInTwo Create two trapezoid generate by the segment
 * @param t current trapezoid
 * @param up_merging vector of trapzoids that will merge above
 * @param low_merging vector of trapezoids that will merge below
 * @param mirror_merge_t trapezoid that will not merge in split in two phase
 * @param newTrapsToReturn vector of new trapezoids
 * @param segment segment inserted
 * @param right_above_segment flag if the right point is above the segment
 * @param left_above_segment flag if the left point is above the segment
 */
void TrapMap::splitInTwo(Trapezoid t,  std::vector<Trapezoid*>& up_merging, std::vector<Trapezoid*>& low_merging, Trapezoid *mirror_merge_t,
                         std::vector<Trapezoid*>& newTrapsToReturn, const cg3::Segment2d& segment, bool& right_above_segment, bool& left_above_segment){
    int idLastTrap;
    cg3::Color colorT;

    // MERGING TRAPEZOID
    if (left_above_segment){
        // trapezoid that has to be merged is in low_merging

        // update merging trapezoid's shape
        low_merging.back()->setSegmentUp(cg3::Segment2d(low_merging.back()->getSegmentUp().p1(),
                                                   findIntersectionVerticalLine(segment, t.getRightPoint())));

        low_merging.back()->setSegmentDown(cg3::Segment2d(low_merging.back()->getSegmentDown().p1(),
                                                     findIntersectionVerticalLine(t.getSegmentDown(), t.getRightPoint())));
        // update right point
        low_merging.back()->setRightPoint(t.getRightPoint());


        //////////////////////
        // NEIGHBOR SETTING //
        //////////////////////
        ///

        if (!right_above_segment){
            // next merge will be above
            low_merging.back()->setTopRightNeigh(t.getTopRightNeigh()); // will be modify
            low_merging.back()->setBottomRightNeigh(t.getBottomRightNeigh());

            if (!Algorithm::pointsAreEquals(t.getRightPoint(), t.getSegmentDown().p2())){
                t.getBottomRightNeigh()->setTopLeftNeigh(low_merging.back());
                t.getBottomRightNeigh()->setBottomLeftNeigh(low_merging.back());
            }
        }

    }else{
        // trapezoid that has to be merged is in up_merging

        // update merging trapezoid's shape
        up_merging.back()->setSegmentUp(cg3::Segment2d(up_merging.back()->getSegmentUp().p1(),
                                                   findIntersectionVerticalLine(t.getSegmentUp(), t.getRightPoint())));
        up_merging.back()->setSegmentDown(cg3::Segment2d(up_merging.back()->getSegmentDown().p1(),
                                                     findIntersectionVerticalLine(segment, t.getRightPoint())));

        up_merging.back()->setRightPoint(t.getRightPoint());
        //////////////////////
        // NEIGHBOR SETTING //
        //////////////////////

        if (right_above_segment){
            // next merge will be below

            up_merging.back()->setTopRightNeigh(t.getTopRightNeigh());
            up_merging.back()->setBottomRightNeigh(t.getBottomRightNeigh()); // successivamente verrà modificato

            if(!Algorithm::pointsAreEquals(t.getRightPoint(),t.getSegmentUp().p2())){
                t.getTopRightNeigh()->setTopLeftNeigh(up_merging.back());
                t.getTopRightNeigh()->setBottomLeftNeigh(up_merging.back());
            }
        }
    }

    // NOT MERGING TRAPEZOID
    idLastTrap = trapezoids.back().getId();
    colorT = cg3::Color(rand()%256, rand()%256, rand()%256);
    if (left_above_segment){
        mirror_merge_t = addNewTrapezoid();
        mirror_merge_t->setTrapezoid(++idLastTrap,
                        t.getSegmentUp(),
                        cg3::Segment2d(findIntersectionVerticalLine(segment, t.getLeftPoint()), findIntersectionVerticalLine(segment,t.getRightPoint())),
                        t.getLeftPoint(), t.getRightPoint(),colorT);

        newTrapsToReturn.push_back(mirror_merge_t);

        //////////////////////
        // NEIGHBOR SETTING //
        //////////////////////
        if (Algorithm::pointsAreEquals(t.getLeftPoint(), t.getSegmentUp().p1())){
             // only one left neighbor
            mirror_merge_t->setNeighbor(up_merging.back(), up_merging.back(),
                                        t.getTopRightNeigh(), t.getBottomRightNeigh());

            if(!Algorithm::pointsAreEquals(up_merging.back()->getRightPoint(), up_merging.back()->getSegmentUp().p2())){
                // up merging has different right neighbors
                up_merging.back()->setBottomRightNeigh(mirror_merge_t);
            }else{
                // up merging has same right neighbors
                up_merging.back()->setTopRightNeigh(mirror_merge_t);
                up_merging.back()->setBottomRightNeigh(mirror_merge_t);
            }

        }else{

            // different left neighbors
            mirror_merge_t->setNeighbor(t.getTopLeftNeigh(), up_merging.back(),
                                        t.getTopRightNeigh(), t.getBottomRightNeigh());


            t.getTopLeftNeigh()->setTopRightNeigh(mirror_merge_t);
            t.getTopLeftNeigh()->setBottomRightNeigh(mirror_merge_t);

            up_merging.back()->setTopRightNeigh(mirror_merge_t);
            up_merging.back()->setBottomRightNeigh(mirror_merge_t);

        }

         if (right_above_segment &&
                 !Algorithm::pointsAreEquals(t.getRightPoint(), t.getSegmentUp().p2())){
             // update upper right neighbor
             t.getTopRightNeigh()->setTopLeftNeigh(mirror_merge_t);
             t.getTopRightNeigh()->setBottomLeftNeigh(mirror_merge_t);

         }

         up_merging.push_back(mirror_merge_t);

    }else{
        mirror_merge_t = addNewTrapezoid();
        mirror_merge_t->setTrapezoid(++idLastTrap,
                        cg3::Segment2d(findIntersectionVerticalLine(segment, t.getLeftPoint()), findIntersectionVerticalLine(segment,t.getRightPoint())),
                        t.getSegmentDown(),
                        t.getLeftPoint(), t.getRightPoint(),colorT);


        newTrapsToReturn.push_back(mirror_merge_t);

        //////////////////////
        // NEIGHBOR SETTING //
        //////////////////////
        if (Algorithm::pointsAreEquals(t.getLeftPoint(), t.getSegmentDown().p1())){
            // same left neighbors
            mirror_merge_t->setNeighbor(low_merging.back(), low_merging.back(),
                                        t.getTopRightNeigh(), t.getBottomRightNeigh());

            if (!Algorithm::pointsAreEquals(low_merging.back()->getRightPoint(), low_merging.back()->getSegmentDown().p2())){
                //low merging has different right neighbors
                low_merging.back()->setTopRightNeigh(mirror_merge_t);
            }else{
                // low merging has same right neighbors
                low_merging.back()->setTopRightNeigh(mirror_merge_t);
                low_merging.back()->setBottomRightNeigh(mirror_merge_t);
            }

        }else{
            // different left neighbors
            mirror_merge_t->setNeighbor(low_merging.back(), t.getBottomLeftNeigh(),
                                        t.getTopRightNeigh(), t.getBottomRightNeigh());

            t.getBottomLeftNeigh()->setTopRightNeigh(mirror_merge_t);
            t.getBottomLeftNeigh()->setBottomRightNeigh(mirror_merge_t);

            low_merging.back()->setTopRightNeigh(mirror_merge_t);
            low_merging.back()->setBottomRightNeigh(mirror_merge_t);
        }

        if (!right_above_segment &&
                !Algorithm::pointsAreEquals(t.getRightPoint(), t.getSegmentDown().p2())){
            // update bottom right neighbor
            t.getBottomRightNeigh()->setTopLeftNeigh(mirror_merge_t);
            t.getBottomRightNeigh()->setBottomLeftNeigh(mirror_merge_t);
        }

        low_merging.push_back(mirror_merge_t);
    }
}
/**
 * @brief TrapMap::assignNeighborsLeftSplit update neighbors about left split
 * @param t current trapezoid
 * @param left_t trapezoid that is left
 * @param no_merge_t trapezoid that does not merge
 * @param merge_t trapezoid that merge
 * @param left_coincident flag if is left coincident
 * @param right_above_segment flag if the right point is above the segment
 */
void TrapMap::assignNeighborsLeftSplit(Trapezoid t, Trapezoid *left_t, Trapezoid *no_merge_t, Trapezoid *merge_t,
                                       bool& left_coincident, bool& right_above_segment){
    //////////////////////
    // NEIGHBOR SETTING //
    //      LEFT_T      //
    //////////////////////

    if (!left_coincident){
        // assign new trapezoid's neighbor
        if (right_above_segment){
            left_t->setTopRightNeigh(no_merge_t);
            left_t->setBottomRightNeigh(merge_t);
        }else{
            left_t->setTopRightNeigh(merge_t);
            left_t->setBottomRightNeigh(no_merge_t);
        }

        // assign old neighbor inherited from current trapezoid t
        left_t->setTopLeftNeigh(t.getTopLeftNeigh());
        left_t->setBottomLeftNeigh(t.getBottomLeftNeigh());

        // update other trapezoids affected by left_t
        if (t.getBottomLeftNeigh() != nullptr && t.getTopLeftNeigh() != nullptr){
            if (t.getBottomLeftNeigh()->getId() == t.getTopLeftNeigh()->getId()){
                // upper and lower neighbor are the same
                if (t.getTopLeftNeigh()->getTopRightNeigh()->getId() == t.getTopLeftNeigh()->getBottomRightNeigh()->getId()){
                    // left neighbor has the same right neighbors
                    t.getTopLeftNeigh()->setTopRightNeigh(left_t);
                    t.getTopLeftNeigh()->setBottomRightNeigh(left_t);
                }else{
                    if (t.getId() == t.getTopLeftNeigh()->getTopRightNeigh()->getId()){
                        t.getTopLeftNeigh()->setTopRightNeigh(left_t);
                    }else{
                        t.getTopLeftNeigh()->setBottomRightNeigh(left_t);
                    }
                }
            }else{
                // upper and lower neighbor are different trapezoids
                // i have to change both neighbor
                t.getTopLeftNeigh()->setTopRightNeigh(left_t);
                t.getTopLeftNeigh()->setBottomRightNeigh(left_t);

                t.getBottomLeftNeigh()->setTopRightNeigh(left_t);
                t.getBottomLeftNeigh()->setBottomRightNeigh(left_t);
            }
        }
    }
    //////////////////////
    // NEIGHBOR SETTING //
    //    NO_MERGE_T    //
    //////////////////////

    if(!left_coincident){
        // assign new trapezoid's neighbor
        no_merge_t->setTopLeftNeigh(left_t);
        no_merge_t->setBottomLeftNeigh(left_t);

        // assign old neighbor inherited from current trapezoid t
        no_merge_t->setTopRightNeigh(t.getTopRightNeigh());
        no_merge_t->setBottomRightNeigh(t.getBottomRightNeigh());

        // update other trapezoids affected by no_merge_t
        if (t.getTopRightNeigh()->getId() != t.getBottomRightNeigh()->getId()){
            if (right_above_segment){
                // update trapezoid that won't be modified
                t.getTopRightNeigh()->setTopLeftNeigh(no_merge_t);
                t.getTopRightNeigh()->setBottomLeftNeigh(no_merge_t);
            }else{
                t.getBottomRightNeigh()->setTopLeftNeigh(no_merge_t);
                t.getBottomRightNeigh()->setBottomLeftNeigh(no_merge_t);
            }
        }
    }else{
        //left coincident

        if (no_merge_t->isLeftDegenerate()){
            // left degenerate

            no_merge_t->setNeighbor(nullptr, nullptr,
                                    t.getTopRightNeigh(), t.getBottomRightNeigh());
            if (right_above_segment){
                if (!Algorithm::pointsAreEquals(t.getRightPoint(), t.getSegmentUp().p2())){
                    t.getTopRightNeigh()->setTopLeftNeigh(no_merge_t);
                    t.getTopRightNeigh()->setBottomLeftNeigh(no_merge_t);
                }
            }else{
                if (!Algorithm::pointsAreEquals(t.getRightPoint(), t.getSegmentDown().p2())){
                    t.getBottomRightNeigh()->setTopLeftNeigh(no_merge_t);
                    t.getBottomRightNeigh()->setBottomLeftNeigh(no_merge_t);
                }
            }
        }else{
            // not left degenerate

            // UPDATE LEFT NEIGHBORS
            if (right_above_segment){
                // right point is above
                if (Algorithm::pointsAreEquals(t.getLeftPoint(), t.getSegmentDown().p1())){
                    no_merge_t->setNeighbor(t.getTopLeftNeigh(), t.getBottomLeftNeigh(),
                                            t.getTopRightNeigh(), t.getBottomRightNeigh());
                    if (t.getTopLeftNeigh()->sameRightNeighbor()){
                        t.getTopLeftNeigh()->setTopRightNeigh(no_merge_t);
                        t.getTopLeftNeigh()->setBottomRightNeigh(no_merge_t);
                    }else
                        t.getTopLeftNeigh()->setTopRightNeigh(no_merge_t);
                }else{
                    no_merge_t->setNeighbor(t.getTopLeftNeigh(), t.getTopLeftNeigh(),
                                            t.getTopRightNeigh(), t.getBottomRightNeigh());
                    t.getTopLeftNeigh()->setTopRightNeigh(no_merge_t);
                    t.getTopLeftNeigh()->setBottomRightNeigh(no_merge_t);
                }

                if (!Algorithm::pointsAreEquals(t.getRightPoint(), t.getSegmentUp().p2())){
                    t.getTopRightNeigh()->setTopLeftNeigh(no_merge_t);
                    t.getTopRightNeigh()->setBottomLeftNeigh(no_merge_t);
                }


            }else{
                // right point is below
                if (Algorithm::pointsAreEquals(t.getLeftPoint(), t.getSegmentUp().p1())){
                    // same left neighbors
                    no_merge_t->setNeighbor(t.getTopLeftNeigh(), t.getBottomLeftNeigh(),
                                            t.getTopRightNeigh(), t.getBottomRightNeigh());

                    if (t.getTopLeftNeigh()->sameRightNeighbor()){
                        t.getTopLeftNeigh()->setTopRightNeigh(no_merge_t);
                        t.getTopLeftNeigh()->setBottomRightNeigh(no_merge_t);
                    }else
                        t.getTopLeftNeigh()->setBottomRightNeigh(no_merge_t);
                }else{
                    // different left neighbors
                    no_merge_t->setNeighbor(t.getBottomLeftNeigh(), t.getBottomLeftNeigh(),
                                            t.getTopRightNeigh(), t.getBottomRightNeigh());

                    t.getBottomLeftNeigh()->setTopRightNeigh(no_merge_t);
                    t.getBottomLeftNeigh()->setBottomRightNeigh(no_merge_t);
                }

                if (!Algorithm::pointsAreEquals(t.getRightPoint(), t.getSegmentDown().p2())){
                    t.getBottomRightNeigh()->setTopLeftNeigh(no_merge_t);
                    t.getBottomRightNeigh()->setBottomLeftNeigh(no_merge_t);
                }

            }
        }
    }

    //////////////////////
    // NEIGHBOR SETTING //
    //    MERGE_T       //
    //////////////////////

    if (!left_coincident){
        // assign new trapezoid's neighbor
        merge_t->setTopLeftNeigh(left_t);
        merge_t->setBottomLeftNeigh(left_t);

        // assign old neighbor inherited from current trapezoid t
        if (right_above_segment){
            merge_t->setTopRightNeigh(t.getBottomRightNeigh());
            merge_t->setBottomRightNeigh(t.getBottomRightNeigh());
        }else{
            merge_t->setTopRightNeigh(t.getTopRightNeigh());
            merge_t->setBottomRightNeigh(t.getTopRightNeigh());
        }
    }else{
        // left coincident
        if (t.getTopLeftNeigh() != nullptr && t.getBottomLeftNeigh() != nullptr){
            if (t.getTopLeftNeigh()->getId() == t.getBottomLeftNeigh()->getId()){
                if (!merge_t->isLeftDegenerate()){
                    merge_t->setNeighbor(t.getTopLeftNeigh(),t.getBottomLeftNeigh(),
                                         t.getTopRightNeigh(), t.getBottomRightNeigh());

                    if (t.getTopLeftNeigh()->sameRightNeighbor()){
                        t.getTopLeftNeigh()->setTopRightNeigh(merge_t);
                        t.getTopLeftNeigh()->setBottomRightNeigh(merge_t);
                    }else{
                        if(right_above_segment){
                            t.getTopLeftNeigh()->setBottomRightNeigh(merge_t);
                        }else{
                            t.getTopLeftNeigh()->setTopRightNeigh(merge_t);
                        }
                    }
                }else{
                    // degenerate case
                    merge_t->setNeighbor(nullptr, nullptr,
                                         t.getTopRightNeigh(), t.getBottomRightNeigh());
                }
            }else{
                //current trapezoid has different left neighbor
                if (right_above_segment){
                    merge_t->setNeighbor(t.getBottomLeftNeigh(),t.getBottomLeftNeigh(),
                                         t.getBottomRightNeigh(), t.getBottomRightNeigh());

                    t.getBottomLeftNeigh()->setTopRightNeigh(merge_t);
                    t.getBottomLeftNeigh()->setBottomRightNeigh(merge_t);

                }else{
                    merge_t->setNeighbor(t.getTopLeftNeigh(),t.getTopLeftNeigh(),
                                         t.getTopRightNeigh(), t.getTopRightNeigh());

                    t.getTopLeftNeigh()->setTopRightNeigh(merge_t);
                    t.getTopLeftNeigh()->setBottomRightNeigh(merge_t);
                }
            }
        }

    }
}
/**
 * @brief TrapMap::assignNeighborsRightSplit update neighbors about left split
 * @param t current trapezoid
 * @param right traepzoid that is right
 * @param no_merge_right_t trapezoid that does not merge
 * @param up_merging vector of trapezoids that are above the segment
 * @param low_merging vector of trapezoids that are below the segment
 * @param segment segment inserted
 * @param right_coincident flag if is right coincident
 */
void TrapMap::assignNeighborsRightSplit(Trapezoid t, Trapezoid *right, Trapezoid *no_merge_right_t, std::vector<Trapezoid*>& up_merging,
                                        std::vector<Trapezoid*>& low_merging, bool& right_coincident, bool& left_above_segment){
    //////////////////////
    // NEIGHBOR SETTING //
    //       RIGHT      //
    //////////////////////
    if (!right_coincident){
        right->setTopRightNeigh(t.getTopRightNeigh());
        right->setBottomRightNeigh(t.getBottomRightNeigh());
        if (left_above_segment){
            right->setTopLeftNeigh(no_merge_right_t);
            right->setBottomLeftNeigh(low_merging.back());
        }else{
            right->setTopLeftNeigh(up_merging.back());
            right->setBottomLeftNeigh(no_merge_right_t);
        }

        if (t.getBottomRightNeigh() != nullptr && t.getTopRightNeigh() != nullptr){
            if (t.sameRightNeighbor()){
                if (Algorithm::pointsAreEquals(t.getTopRightNeigh()->getLeftPoint(),
                                               t.getTopRightNeigh()->getSegmentDown().p1()) ||
                        Algorithm::pointsAreEquals(t.getTopRightNeigh()->getLeftPoint(),
                                                   t.getTopRightNeigh()->getSegmentUp().p1()) ){
                    t.getTopRightNeigh()->setTopLeftNeigh(right);
                    t.getTopRightNeigh()->setBottomLeftNeigh(right);
                }else{
                    if (t.getId() == t.getTopRightNeigh()->getTopLeftNeigh()->getId()){
                        t.getTopRightNeigh()->setTopLeftNeigh(right);
                    }else{
                        t.getTopRightNeigh()->setBottomLeftNeigh(right);
                    }
                }
            }else{
                t.getTopRightNeigh()->setTopLeftNeigh(right);
                t.getTopRightNeigh()->setBottomLeftNeigh(right);

                t.getBottomRightNeigh()->setTopLeftNeigh(right);
                t.getBottomRightNeigh()->setBottomLeftNeigh(right);
            }
        }
    }
    //////////////////////
    // NEIGHBOR SETTING //
    //  NO_MERGE_RIGHT  //
    //////////////////////

    if (!right_coincident){
        no_merge_right_t->setTopRightNeigh(right);
        no_merge_right_t->setBottomRightNeigh(right);

        if (left_above_segment){
            // no merge is above
            if (Algorithm::pointsAreEquals(t.getLeftPoint(), t.getSegmentUp().p1())){
                // current trapezoid has same left neighbors
                no_merge_right_t->setTopLeftNeigh(up_merging.back());
                no_merge_right_t->setBottomLeftNeigh(up_merging.back());

                if (Algorithm::pointsAreEquals(t.getTopLeftNeigh()->getRightPoint(), t.getTopLeftNeigh()->getSegmentUp().p2())){
                    // t.getupperleft has same right neighbor
                    up_merging.back()->setTopRightNeigh(no_merge_right_t);
                    up_merging.back()->setBottomRightNeigh(no_merge_right_t);
                }else
                    // t.getupperleft has different right neigbors
                    up_merging.back()->setBottomRightNeigh(no_merge_right_t);
            }else{
                // current trapezoid has different left neighbors
                no_merge_right_t->setTopLeftNeigh(t.getTopLeftNeigh());
                no_merge_right_t->setBottomLeftNeigh(up_merging.back());

                up_merging.back()->setTopRightNeigh(no_merge_right_t);
                up_merging.back()->setBottomRightNeigh(no_merge_right_t);

                t.getTopLeftNeigh()->setTopRightNeigh(no_merge_right_t);
                t.getTopLeftNeigh()->setBottomRightNeigh(no_merge_right_t);
            }
        }else{
            // no merge is below
            if (Algorithm::pointsAreEquals(t.getLeftPoint(), t.getSegmentDown().p1())){
                // current trapezoid had same left neighbors
                no_merge_right_t->setTopLeftNeigh(low_merging.back());
                no_merge_right_t->setBottomLeftNeigh(low_merging.back());

                if(Algorithm::pointsAreEquals(t.getTopLeftNeigh()->getRightPoint(), t.getTopLeftNeigh()->getSegmentDown().p2())){
                    low_merging.back()->setTopRightNeigh(no_merge_right_t);
                    low_merging.back()->setBottomRightNeigh(no_merge_right_t);
                } else{
                    low_merging.back()->setTopRightNeigh(no_merge_right_t);
                }

            }else{
                no_merge_right_t->setTopLeftNeigh(low_merging.back());
                no_merge_right_t->setBottomLeftNeigh(t.getBottomLeftNeigh());

                low_merging.back()->setTopRightNeigh(no_merge_right_t);
                low_merging.back()->setBottomRightNeigh(no_merge_right_t);

                t.getBottomLeftNeigh()->setTopRightNeigh(no_merge_right_t);
                t.getBottomLeftNeigh()->setBottomRightNeigh(no_merge_right_t);
            }
        }
    }else{
        // segment is right coincident
        if (left_above_segment){
            // merge is above
            if (Algorithm::pointsAreEquals(t.getLeftPoint(), t.getSegmentUp().p1())){
                // same lelt neighbors
                if (no_merge_right_t->isRightDegenerate()){
                    // no merge is right degenerate
                    no_merge_right_t->setNeighbor(up_merging.back(), up_merging.back(),
                                                  nullptr, nullptr);

                    if (Algorithm::pointsAreEquals(up_merging.back()->getRightPoint(), up_merging.back()->getSegmentUp().p2())){
                        // up_merging has same right neighbors
                        up_merging.back()->setTopRightNeigh(no_merge_right_t);
                        up_merging.back()->setBottomRightNeigh(no_merge_right_t);
                    }else{
                        // up_merging has different right neighbors
                        up_merging.back()->setBottomRightNeigh(no_merge_right_t);
                    }

                }else{
                    // no merge IS NOT right degenerate
                    no_merge_right_t->setNeighbor(up_merging.back(), up_merging.back(),
                                                  t.getTopRightNeigh(), t.getTopRightNeigh());

                    if (Algorithm::pointsAreEquals(up_merging.back()->getRightPoint(), up_merging.back()->getSegmentUp().p2())){
                        // up_merging has same right neighbors
                        up_merging.back()->setTopRightNeigh(no_merge_right_t);
                        up_merging.back()->setBottomRightNeigh(no_merge_right_t);
                    }else{
                        // up_merging has different right neighbors
                        up_merging.back()->setBottomRightNeigh(no_merge_right_t);
                    }

                    if (t.getTopRightNeigh()->sameLeftNeighbor()){
                        t.getTopRightNeigh()->setTopLeftNeigh(no_merge_right_t);
                        t.getTopRightNeigh()->setBottomLeftNeigh(no_merge_right_t);
                    }else{
                        t.getTopRightNeigh()->setTopLeftNeigh(no_merge_right_t);
                    }

                }
            }else{
                // different left neighors
                if (no_merge_right_t->isRightDegenerate()){
                    // no merge is degenerate
                    no_merge_right_t->setNeighbor(t.getTopLeftNeigh(), up_merging.back(),
                                                  nullptr, nullptr);

                    t.getTopLeftNeigh()->setTopRightNeigh(no_merge_right_t);
                    t.getTopLeftNeigh()->setBottomRightNeigh(no_merge_right_t);

                    up_merging.back()->setTopRightNeigh(no_merge_right_t);
                    up_merging.back()->setBottomRightNeigh(no_merge_right_t);
                }else{
                    // no merge is not degenerate
                    no_merge_right_t->setNeighbor(t.getTopLeftNeigh(), up_merging.back(),
                                                  t.getTopRightNeigh(), t.getTopRightNeigh());

                    t.getTopLeftNeigh()->setTopRightNeigh(no_merge_right_t);
                    t.getTopLeftNeigh()->setBottomRightNeigh(no_merge_right_t);

                    up_merging.back()->setTopRightNeigh(no_merge_right_t);
                    up_merging.back()->setBottomRightNeigh(no_merge_right_t);



                    if (!Algorithm::pointsAreEquals(t.getRightPoint(), t.getSegmentDown().p2())){
                        // different right neighbors
                        t.getTopRightNeigh()->setTopLeftNeigh(no_merge_right_t);
                        t.getTopRightNeigh()->setBottomLeftNeigh(no_merge_right_t);
                    }else{
                        // same right neighbors
                        if (t.getTopRightNeigh()->sameLeftNeighbor()){
                            // right neighbor has same left neighbors
                            t.getTopRightNeigh()->setTopLeftNeigh(no_merge_right_t);
                            t.getTopRightNeigh()->setBottomLeftNeigh(no_merge_right_t);
                        }else{
                            t.getTopRightNeigh()->setTopLeftNeigh(no_merge_right_t);
                        }
                    }

                }
            }

        }else{
            // merge is above
            if (Algorithm::pointsAreEquals(t.getLeftPoint(), t.getSegmentDown().p1())){
                if (no_merge_right_t->isRightDegenerate()){
                    // no merge is degenerate
                    no_merge_right_t->setNeighbor(low_merging.back(), low_merging.back(),
                                                  nullptr, nullptr);

                    if (Algorithm::pointsAreEquals(low_merging.back()->getRightPoint(), low_merging.back()->getSegmentDown().p2())){

                        low_merging.back()->setTopRightNeigh(no_merge_right_t);
                        low_merging.back()->setBottomRightNeigh(no_merge_right_t);
                    }else{
                        low_merging.back()->setTopRightNeigh(no_merge_right_t);
                    }

                }else{
                    // no merge IS NOT degenerate
                    no_merge_right_t->setNeighbor(low_merging.back(), low_merging.back(),
                                                  t.getBottomRightNeigh(), t.getBottomRightNeigh());

                    if (Algorithm::pointsAreEquals(low_merging.back()->getRightPoint(), low_merging.back()->getSegmentDown().p2())){
                        // low merging has same right neighbors
                        low_merging.back()->setTopRightNeigh(no_merge_right_t);
                        low_merging.back()->setBottomRightNeigh(no_merge_right_t);
                    }else{
                        // low merging has different right neighbors
                        low_merging.back()->setTopRightNeigh(no_merge_right_t);
                    }

                    if (t.getBottomRightNeigh()->sameLeftNeighbor()){
                        t.getBottomRightNeigh()->setTopLeftNeigh(no_merge_right_t);
                        t.getBottomRightNeigh()->setBottomLeftNeigh(no_merge_right_t);
                    }else{
                        t.getBottomRightNeigh()->setBottomLeftNeigh(no_merge_right_t);
                    }

                }
            }else{
                if (no_merge_right_t->isRightDegenerate()){
                    no_merge_right_t->setNeighbor(low_merging.back(), t.getBottomLeftNeigh(),
                                                  nullptr, nullptr);

                    low_merging.back()->setTopRightNeigh(no_merge_right_t);
                    low_merging.back()->setBottomRightNeigh(no_merge_right_t);

                    t.getBottomLeftNeigh()->setTopRightNeigh(no_merge_right_t);
                    t.getBottomLeftNeigh()->setBottomRightNeigh(no_merge_right_t);
                }else{
                    no_merge_right_t->setNeighbor(low_merging.back(), t.getBottomLeftNeigh(),
                                                  t.getBottomRightNeigh(), t.getBottomRightNeigh());

                    low_merging.back()->setTopRightNeigh(no_merge_right_t);
                    low_merging.back()->setBottomRightNeigh(no_merge_right_t);

                    t.getBottomLeftNeigh()->setTopRightNeigh(no_merge_right_t);
                    t.getBottomLeftNeigh()->setBottomRightNeigh(no_merge_right_t);

                    if (!Algorithm::pointsAreEquals(t.getRightPoint(), t.getSegmentUp().p2())){
                        // different right neighbors
                        t.getBottomRightNeigh()->setTopLeftNeigh(no_merge_right_t);
                        t.getBottomRightNeigh()->setBottomLeftNeigh(no_merge_right_t);
                    }else{
                        // same right neighbors
                        if (t.getBottomRightNeigh()->sameLeftNeighbor()){
                            // right neighbor has same left neighbors
                            t.getBottomRightNeigh()->setTopLeftNeigh(no_merge_right_t);
                            t.getBottomRightNeigh()->setBottomLeftNeigh(no_merge_right_t);
                        }else{
                            t.getBottomRightNeigh()->setBottomLeftNeigh(no_merge_right_t);
                        }
                    }
                }
            }
        }
    }

    if (!right_coincident){
        if (left_above_segment){
            low_merging.back()->setTopRightNeigh(right);
            low_merging.back()->setBottomRightNeigh(right);
        }else{
            up_merging.back()->setTopRightNeigh(right);
            up_merging.back()->setBottomRightNeigh(right);
        }
    }else{
        // right coincident
        if (left_above_segment){
            // merge is below
            if (low_merging.back()->isRightDegenerate()){
                // merge is degenerate
                low_merging.back()->setTopRightNeigh(nullptr);
                low_merging.back()->setBottomRightNeigh(nullptr);
            }else{
                // merge is not degenerate
                if (Algorithm::pointsAreEquals(t.getRightPoint(), t.getSegmentUp().p2())){
                    low_merging.back()->setTopRightNeigh(t.getTopRightNeigh());
                    low_merging.back()->setBottomRightNeigh(t.getTopRightNeigh());

                    if (t.getTopRightNeigh()->sameLeftNeighbor()){
                        t.getTopRightNeigh()->setTopLeftNeigh(low_merging.back());
                        t.getTopRightNeigh()->setBottomLeftNeigh(low_merging.back());
                    }else
                        t.getTopRightNeigh()->setBottomLeftNeigh(low_merging.back());
                }else{

                    low_merging.back()->setTopRightNeigh(t.getBottomRightNeigh());
                    low_merging.back()->setBottomRightNeigh(t.getBottomRightNeigh());

                    t.getBottomRightNeigh()->setTopLeftNeigh(low_merging.back());
                    t.getBottomRightNeigh()->setBottomLeftNeigh(low_merging.back());
                }
            }
        }else{
            // merge is above
            if (up_merging.back()->isRightDegenerate()){
                // merge is degenerate
                up_merging.back()->setTopRightNeigh(nullptr);
                up_merging.back()->setBottomRightNeigh(nullptr);
            }else{
                // merge is not degenerate
                if (Algorithm::pointsAreEquals(t.getRightPoint(), t.getSegmentDown().p2())){
                    //right neighbor has different left neighbors
                    up_merging.back()->setTopRightNeigh(t.getTopRightNeigh());
                    up_merging.back()->setBottomRightNeigh(t.getTopRightNeigh());

                    if (t.getTopRightNeigh()->sameLeftNeighbor()){
                        t.getTopRightNeigh()->setTopLeftNeigh(up_merging.back());
                        t.getTopRightNeigh()->setBottomLeftNeigh(up_merging.back());
                    }else
                        t.getTopRightNeigh()->setTopLeftNeigh(up_merging.back());
                }else{
                    //right neighbor has same left neighbor
                    up_merging.back()->setTopRightNeigh(t.getTopRightNeigh());
                    up_merging.back()->setBottomRightNeigh(t.getTopRightNeigh());

                    t.getTopRightNeigh()->setTopLeftNeigh(up_merging.back());
                    t.getTopRightNeigh()->setBottomLeftNeigh(up_merging.back());
                }
            }
        }
    }
}

/**
 * @brief TrapMap::newTrapezoidsMultipleSplit Create trapezoids generated by a segment that cross multiple trapezoids
 * @param segment segment inserted
 * @param traps vector of trapezoids crossed by segment
 * @param left_coincident flag if is left coincident
 * @param right_coincident flag if is right coincident
 * @return
 */
std::vector<Trapezoid*> TrapMap::newTrapezoidsMultipleSplit(const cg3::Segment2d& segment,  std::vector<Trapezoid*>& traps,
                                                            bool &left_coincident, bool &right_coincident){
    cg3::Point2d p1, q1;
    Trapezoid t;
    cg3::Color colorT;
    std::vector<Trapezoid*> up_merging, low_merging, newTrapsToReturn;
    Trapezoid *left_t = nullptr, *no_merge_t=nullptr, *merge_t=nullptr, *no_merge_right_t=nullptr, *right=nullptr, *mirror_merge_t=nullptr;
    bool left_above_segment = false, right_above_segment = false;


    int idLastTrap = trapezoids.back().getId();

    // find if the segment is left, right or both coincident
    if (segment.p1().operator==(traps.front()->getLeftPoint()))
        left_coincident = true;
    if(segment.p2().operator==(traps.back()->getRightPoint()))
        right_coincident = true;

    // create 3 new default trapezoids
    if (!left_coincident)
        left_t = addNewTrapezoid();
    no_merge_t = addNewTrapezoid();
    merge_t = addNewTrapezoid();


    for(size_t i = 0; i <= traps.size() -1; i++){

        // get the information about the current trapezoid
        t = *(traps[i]);

        // get information about left and right point of the current trapezoid
        left_above_segment = Algorithm::pointIsAboveSegment(segment, t.getLeftPoint());
        right_above_segment = Algorithm::pointIsAboveSegment(segment, t.getRightPoint());

        if (i == 0){

            // create left, top, bottom trapezoids
            splitInThreeLeft(left_t, no_merge_t, merge_t, low_merging, up_merging, t, segment, idLastTrap, right_above_segment);

            // insert new trapezoids for DAG
            if (!left_coincident)
                newTrapsToReturn.push_back(left_t);
            newTrapsToReturn.push_back(no_merge_t);
            newTrapsToReturn.push_back(merge_t);

            // update neighbors
            assignNeighborsLeftSplit(t, left_t, no_merge_t, merge_t, left_coincident, right_above_segment);

        }else if (i < traps.size() - 1){
            // create top and bottom in split in two
            splitInTwo(t, up_merging, low_merging, mirror_merge_t, newTrapsToReturn, segment, right_above_segment, left_above_segment);

        }else{

            idLastTrap = trapezoids.back().getId();

            // create 3 new default trapezoids
            no_merge_right_t = addNewTrapezoid();
            if (!right_coincident)
                right = addNewTrapezoid();

            // create top, bottom, right trapezoids
            splitInThreeRight(no_merge_right_t, right,low_merging, up_merging, t, segment, idLastTrap, left_above_segment);

            // insert new trapezoids for DAG
            newTrapsToReturn.push_back(no_merge_right_t);
            if (!right_coincident)
                newTrapsToReturn.push_back(right);

            // update neighbors
            assignNeighborsRightSplit(t, right, no_merge_right_t, up_merging, low_merging, right_coincident, left_above_segment);
        }
    }
    return newTrapsToReturn;
}

bool TrapMap::findID(Trapezoid t){
    for (Trapezoid t1 : trapezoids){
        if (t.getId() == t1.getId())
            return true;
    }

    return false;
}
void TrapMap::compareNeigh(){
    bool neig = true;
    const Trapezoid tr;
    std::string s;
    for (Trapezoid t : getTrapezoids()){
        if (neig){
            s += "ID: ";
            s += std::to_string(t.getId());
            if (t.getTopLeftNeigh() != nullptr && t.getBottomLeftNeigh() != nullptr){
                s += "U-L ";
                s += std::to_string(t.getTopLeftNeigh()->getId());
                s += " B-L ";
                s += std::to_string(t.getBottomLeftNeigh()->getId());


                if (!findID(*t.getTopLeftNeigh())){
                    std::cerr << "t: " << t.getId() << " U-L: " << t.getTopLeftNeigh()->getId() << " -> NOT FOUND" << std::endl;
                }
                if (!findID(*t.getBottomLeftNeigh())){
                    std::cerr << "t: " << t.getId() << "B-L: " << t.getBottomLeftNeigh()->getId() << " -> NOT FOUND" << std::endl;
                }
            }
            else{
                s += "U-L NULL B-L NULL";
            }

            if (t.getTopRightNeigh() != nullptr && t.getBottomRightNeigh() != nullptr){

                s += "U-R ";
                s += std::to_string(t.getTopRightNeigh()->getId());
                s += " B-R ";
                s += std::to_string(t.getBottomRightNeigh()->getId());


                if (!(findID(*t.getTopRightNeigh()))){
                    std::cerr << "t: " << t.getId() << " U-R: " << t.getTopRightNeigh()->getId() << " -> NOT FOUND" << std::endl;
                }

                if (!(findID(*t.getBottomRightNeigh()))){
                    std::cerr << "t: " << t.getId() << " B-R: " << t.getBottomRightNeigh()->getId() << " -> NOT FOUND" << std::endl;
                }
            }
            else
                s += "U-R NULL B-R NULL";
        }

   }

    if (prev != ""){
        if (s.compare(prev) == 0){
            std::cout << "i neigh sono uguali" << std::endl;
        }else{
            std::cerr << "i neigh sono DIVERSII!!!!!!" << std::endl;
        }
    }

    prev = s;
//        std::cout << s << std::endl;
}
